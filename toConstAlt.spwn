extract obj_props
extract $

/*
if you want to increase the range, you need to add new number to the twoPower array until it above the number you need
and then turn off the error message on line 46
*/

floorLog2 = (num){
//  while haven't been implemented, so until then, ill have to use this stupid algorithm
    twoPower = [
        2, //2^1
        4,
        8,
        16,
        32,
        64,
        128,
        256,
        512,
        1024,
        2048 //2^ 11
        ]

    let result = 0
    for i in twoPower{
        if num >= i{
            result++
        }else{
            break
        }
    }
    return result
}

// this actually don't have to be a counter impl. but y not
impl @counter {
    toConstMove:(
        self, 
        #[desc("Array or range of possible output values")] range: @range
    ) {
        let rangeSize = range.end - range.start
        if rangeSize >= 4096 {
            throw ("range size too huge, please reduce the size to below 4096 or modify the toConstAlt.spwn file")
        }
        triggerPathCount = floorLog2(rangeSize)

        if range.start != 0{
//          move the obj to the leftmost posible point
            -> call_with_delay((triggerPathCount) / 20, !{
                -> return range.start
            })
        }

//      Context splitting - for generating multiple trigger
//      it's like a for loop, but start executing everything at the same time.
//      so it's like creating branch timeline which all executing at same time, each for all posible value in i
        branchMultiverse = (range){
            for val in range {
            ->return val
            }
        }
        i = branchMultiverse((triggerPathCount + 1)..0)
        
//      make sure the operation is executed in the right order (but disrupt the multiverse timeline)
        wait((triggerPathCount - i) / 20)
        j = (2^i)

//      count the counter value
        if(self >= j + range.start){
            self -= j
            
            wait((i+1) / 20)

//          execute the move trigger and restore the counter value
            -> return j
            self += j
        }else{
//          re align the timeline (maybe redundant)
            wait((i+1) / 20)
        }
    }
}